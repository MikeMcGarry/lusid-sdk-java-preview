/*
 * LUSID API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.10.1383
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.finbourne.lusid.model;

import java.util.Objects;
import java.util.Arrays;
import com.finbourne.lusid.model.DataDefinition;
import com.finbourne.lusid.model.Link;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * When importing data from an external source there are essentially three levels of interaction with LUSID.  (1) The data is a raw document that LUSID does not understand. You can store and retrieve it but it does not full interact with other documents inside LUSID  (2) The data has a map from fields and paths to &#39;properties&#39; in LUSID. In essence, LUSID can then treat the data as weakly typed (decimal, string) data that can be returned through queries      and where various aggregation requests will then work.  (3) The data is fully translatable into LUSID and understood, in some sense, natively. This means that it can be used for context sensitive calculations such as pricing or risk calculations.  The data map object is designed to allow data to transition from step 1 to 2 and in some cases as an alternative for step 2 to 3.
 */
@ApiModel(description = "When importing data from an external source there are essentially three levels of interaction with LUSID.  (1) The data is a raw document that LUSID does not understand. You can store and retrieve it but it does not full interact with other documents inside LUSID  (2) The data has a map from fields and paths to 'properties' in LUSID. In essence, LUSID can then treat the data as weakly typed (decimal, string) data that can be returned through queries      and where various aggregation requests will then work.  (3) The data is fully translatable into LUSID and understood, in some sense, natively. This means that it can be used for context sensitive calculations such as pricing or risk calculations.  The data map object is designed to allow data to transition from step 1 to 2 and in some cases as an alternative for step 2 to 3.")

public class DataMapping {
  public static final String SERIALIZED_NAME_DATA_FIELD_NAME_MAPPINGS = "dataFieldNameMappings";
  @SerializedName(SERIALIZED_NAME_DATA_FIELD_NAME_MAPPINGS)
  private Map<String, DataDefinition> dataFieldNameMappings = new HashMap<>();

  public static final String SERIALIZED_NAME_LINKS = "links";
  @SerializedName(SERIALIZED_NAME_LINKS)
  private List<Link> links = new ArrayList<>();

  public DataMapping dataFieldNameMappings(Map<String, DataDefinition> dataFieldNameMappings) {
    this.dataFieldNameMappings = dataFieldNameMappings;
    return this;
  }

  public DataMapping putDataFieldNameMappingsItem(String key, DataDefinition dataFieldNameMappingsItem) {
    if (this.dataFieldNameMappings == null) {
      this.dataFieldNameMappings = new HashMap<>();
    }
    this.dataFieldNameMappings.put(key, dataFieldNameMappingsItem);
    return this;
  }

   /**
   * A map from LUSID item keys to data definitions that define the names, types and degree of uniqueness of data provided to LUSID in structured data stores.
   * @return dataFieldNameMappings
  **/
  @ApiModelProperty(value = "A map from LUSID item keys to data definitions that define the names, types and degree of uniqueness of data provided to LUSID in structured data stores.")
  public Map<String, DataDefinition> getDataFieldNameMappings() {
    return dataFieldNameMappings;
  }

  public void setDataFieldNameMappings(Map<String, DataDefinition> dataFieldNameMappings) {
    this.dataFieldNameMappings = dataFieldNameMappings;
  }

  public DataMapping links(List<Link> links) {
    this.links = links;
    return this;
  }

  public DataMapping addLinksItem(Link linksItem) {
    if (this.links == null) {
      this.links = new ArrayList<>();
    }
    this.links.add(linksItem);
    return this;
  }

   /**
   * Get links
   * @return links
  **/
  @ApiModelProperty(value = "")
  public List<Link> getLinks() {
    return links;
  }

  public void setLinks(List<Link> links) {
    this.links = links;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DataMapping dataMapping = (DataMapping) o;
    return Objects.equals(this.dataFieldNameMappings, dataMapping.dataFieldNameMappings) &&
        Objects.equals(this.links, dataMapping.links);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dataFieldNameMappings, links);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DataMapping {\n");
    sb.append("    dataFieldNameMappings: ").append(toIndentedString(dataFieldNameMappings)).append("\n");
    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
