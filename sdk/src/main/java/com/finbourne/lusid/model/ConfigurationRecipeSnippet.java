/*
 * LUSID API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.10.1387
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.finbourne.lusid.model;

import java.util.Objects;
import java.util.Arrays;
import com.finbourne.lusid.model.AggregationOptions;
import com.finbourne.lusid.model.ConfigurationRecipe;
import com.finbourne.lusid.model.MarketDataKeyRule;
import com.finbourne.lusid.model.MarketOptions;
import com.finbourne.lusid.model.PricingOptions;
import com.finbourne.lusid.model.VendorModelRule;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * If it is desired to have multiple recipes, there is a strong likelihood that they will share various components.  A configuration recipe snippet allows a user to define a set of rules that can then be included into a parent recipe.  This allows sharing of common blocks of the recipe.                For example, a user might define a set of rules for resolving Fx and then include them into every recipe used firm-wide, thereby  enforcing consistency. As the rules can be permissioned differently using Shrine, it is possible to enable users to   read but not alter such a rule set.                The same applies to a set of pricing rules.                A configuration snippet must only contain one entry from the available set.                 Recipes are compiled from the set of snippets through a model that is analogous to inheritance.  A recipe can have a set of &#39;parent&#39; recipes from which it inherits. These are specified in the inheritance section of a recipe.  Upon loading, the recipe will fall back on these recipe components for any options or rules that are not explicitly specified in the  named recipe for the request.                This allows control of pricing to be harmonised across a set of desks within an institution. Suppose that, e.g.  there are four desks looking after products under the areas of Fx, Rates, Credit and Exotics.  The model and market data for pricing given asset types would potentially be controlled by the appropriate desk; e.g. rules for Fx market data resolution being  controlled by the Fx desk. The exotics desk would likely depend upon rules for all the other asset classes as well as, say, correlation rules of its own.  It could inherit the market data and model rules from the other desks for finding the appropriate institution-standard data and then overlay that with the correlation rules.                Note that permissioning of the store means that one could decide that only a particular desk or control function could update certain rules. That would assist the abilitiy  to ensure that pricing is performed consistently and provide an audit of changes made to it along with restricting changes to appropriate authorised functions.
 */
@ApiModel(description = "If it is desired to have multiple recipes, there is a strong likelihood that they will share various components.  A configuration recipe snippet allows a user to define a set of rules that can then be included into a parent recipe.  This allows sharing of common blocks of the recipe.                For example, a user might define a set of rules for resolving Fx and then include them into every recipe used firm-wide, thereby  enforcing consistency. As the rules can be permissioned differently using Shrine, it is possible to enable users to   read but not alter such a rule set.                The same applies to a set of pricing rules.                A configuration snippet must only contain one entry from the available set.                 Recipes are compiled from the set of snippets through a model that is analogous to inheritance.  A recipe can have a set of 'parent' recipes from which it inherits. These are specified in the inheritance section of a recipe.  Upon loading, the recipe will fall back on these recipe components for any options or rules that are not explicitly specified in the  named recipe for the request.                This allows control of pricing to be harmonised across a set of desks within an institution. Suppose that, e.g.  there are four desks looking after products under the areas of Fx, Rates, Credit and Exotics.  The model and market data for pricing given asset types would potentially be controlled by the appropriate desk; e.g. rules for Fx market data resolution being  controlled by the Fx desk. The exotics desk would likely depend upon rules for all the other asset classes as well as, say, correlation rules of its own.  It could inherit the market data and model rules from the other desks for finding the appropriate institution-standard data and then overlay that with the correlation rules.                Note that permissioning of the store means that one could decide that only a particular desk or control function could update certain rules. That would assist the abilitiy  to ensure that pricing is performed consistently and provide an audit of changes made to it along with restricting changes to appropriate authorised functions.")

public class ConfigurationRecipeSnippet {
  public static final String SERIALIZED_NAME_AGGREGATION_OPTIONS = "aggregationOptions";
  @SerializedName(SERIALIZED_NAME_AGGREGATION_OPTIONS)
  private AggregationOptions aggregationOptions = null;

  public static final String SERIALIZED_NAME_MODEL_RULES = "modelRules";
  @SerializedName(SERIALIZED_NAME_MODEL_RULES)
  private List<VendorModelRule> modelRules = new ArrayList<>();

  public static final String SERIALIZED_NAME_PRICING_OPTIONS = "pricingOptions";
  @SerializedName(SERIALIZED_NAME_PRICING_OPTIONS)
  private PricingOptions pricingOptions = null;

  public static final String SERIALIZED_NAME_MARKET_RULES = "marketRules";
  @SerializedName(SERIALIZED_NAME_MARKET_RULES)
  private List<MarketDataKeyRule> marketRules = new ArrayList<>();

  public static final String SERIALIZED_NAME_MARKET_OPTIONS = "marketOptions";
  @SerializedName(SERIALIZED_NAME_MARKET_OPTIONS)
  private MarketOptions marketOptions = null;

  public static final String SERIALIZED_NAME_RECIPE = "recipe";
  @SerializedName(SERIALIZED_NAME_RECIPE)
  private ConfigurationRecipe recipe = null;

  public ConfigurationRecipeSnippet aggregationOptions(AggregationOptions aggregationOptions) {
    this.aggregationOptions = aggregationOptions;
    return this;
  }

   /**
   * Get aggregationOptions
   * @return aggregationOptions
  **/
  @ApiModelProperty(value = "")
  public AggregationOptions getAggregationOptions() {
    return aggregationOptions;
  }

  public void setAggregationOptions(AggregationOptions aggregationOptions) {
    this.aggregationOptions = aggregationOptions;
  }

  public ConfigurationRecipeSnippet modelRules(List<VendorModelRule> modelRules) {
    this.modelRules = modelRules;
    return this;
  }

  public ConfigurationRecipeSnippet addModelRulesItem(VendorModelRule modelRulesItem) {
    if (this.modelRules == null) {
      this.modelRules = new ArrayList<>();
    }
    this.modelRules.add(modelRulesItem);
    return this;
  }

   /**
   * The set of model rules that are available. There may be multiple rules for Vendors, but only one per model-instrument pair.  Which of these preference sets is used depends upon the model choice selection if specified, or failing that the global default model specification  in the options.
   * @return modelRules
  **/
  @ApiModelProperty(value = "The set of model rules that are available. There may be multiple rules for Vendors, but only one per model-instrument pair.  Which of these preference sets is used depends upon the model choice selection if specified, or failing that the global default model specification  in the options.")
  public List<VendorModelRule> getModelRules() {
    return modelRules;
  }

  public void setModelRules(List<VendorModelRule> modelRules) {
    this.modelRules = modelRules;
  }

  public ConfigurationRecipeSnippet pricingOptions(PricingOptions pricingOptions) {
    this.pricingOptions = pricingOptions;
    return this;
  }

   /**
   * Get pricingOptions
   * @return pricingOptions
  **/
  @ApiModelProperty(value = "")
  public PricingOptions getPricingOptions() {
    return pricingOptions;
  }

  public void setPricingOptions(PricingOptions pricingOptions) {
    this.pricingOptions = pricingOptions;
  }

  public ConfigurationRecipeSnippet marketRules(List<MarketDataKeyRule> marketRules) {
    this.marketRules = marketRules;
    return this;
  }

  public ConfigurationRecipeSnippet addMarketRulesItem(MarketDataKeyRule marketRulesItem) {
    if (this.marketRules == null) {
      this.marketRules = new ArrayList<>();
    }
    this.marketRules.add(marketRulesItem);
    return this;
  }

   /**
   * The set of rules that define how to resolve particular use cases. These can be relatively general or specific in nature.  Nominally any number are possible and will be processed in order where applicable. However, there is evidently a potential  for increased computational cost where many rules must be applied to resolve data. Ensuring that portfolios are structured in  such a way as to reduce the number of rules required is therefore sensible.
   * @return marketRules
  **/
  @ApiModelProperty(value = "The set of rules that define how to resolve particular use cases. These can be relatively general or specific in nature.  Nominally any number are possible and will be processed in order where applicable. However, there is evidently a potential  for increased computational cost where many rules must be applied to resolve data. Ensuring that portfolios are structured in  such a way as to reduce the number of rules required is therefore sensible.")
  public List<MarketDataKeyRule> getMarketRules() {
    return marketRules;
  }

  public void setMarketRules(List<MarketDataKeyRule> marketRules) {
    this.marketRules = marketRules;
  }

  public ConfigurationRecipeSnippet marketOptions(MarketOptions marketOptions) {
    this.marketOptions = marketOptions;
    return this;
  }

   /**
   * Get marketOptions
   * @return marketOptions
  **/
  @ApiModelProperty(value = "")
  public MarketOptions getMarketOptions() {
    return marketOptions;
  }

  public void setMarketOptions(MarketOptions marketOptions) {
    this.marketOptions = marketOptions;
  }

  public ConfigurationRecipeSnippet recipe(ConfigurationRecipe recipe) {
    this.recipe = recipe;
    return this;
  }

   /**
   * Get recipe
   * @return recipe
  **/
  @ApiModelProperty(value = "")
  public ConfigurationRecipe getRecipe() {
    return recipe;
  }

  public void setRecipe(ConfigurationRecipe recipe) {
    this.recipe = recipe;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConfigurationRecipeSnippet configurationRecipeSnippet = (ConfigurationRecipeSnippet) o;
    return Objects.equals(this.aggregationOptions, configurationRecipeSnippet.aggregationOptions) &&
        Objects.equals(this.modelRules, configurationRecipeSnippet.modelRules) &&
        Objects.equals(this.pricingOptions, configurationRecipeSnippet.pricingOptions) &&
        Objects.equals(this.marketRules, configurationRecipeSnippet.marketRules) &&
        Objects.equals(this.marketOptions, configurationRecipeSnippet.marketOptions) &&
        Objects.equals(this.recipe, configurationRecipeSnippet.recipe);
  }

  @Override
  public int hashCode() {
    return Objects.hash(aggregationOptions, modelRules, pricingOptions, marketRules, marketOptions, recipe);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConfigurationRecipeSnippet {\n");
    sb.append("    aggregationOptions: ").append(toIndentedString(aggregationOptions)).append("\n");
    sb.append("    modelRules: ").append(toIndentedString(modelRules)).append("\n");
    sb.append("    pricingOptions: ").append(toIndentedString(pricingOptions)).append("\n");
    sb.append("    marketRules: ").append(toIndentedString(marketRules)).append("\n");
    sb.append("    marketOptions: ").append(toIndentedString(marketOptions)).append("\n");
    sb.append("    recipe: ").append(toIndentedString(recipe)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
