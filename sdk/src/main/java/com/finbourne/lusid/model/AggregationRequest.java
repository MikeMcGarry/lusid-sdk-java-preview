/*
 * LUSID API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.10.1383
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.finbourne.lusid.model;

import java.util.Objects;
import java.util.Arrays;
import com.finbourne.lusid.model.AggregateSpec;
import com.finbourne.lusid.model.ConfigurationRecipe;
import com.finbourne.lusid.model.OrderBySpec;
import com.finbourne.lusid.model.PropertyFilter;
import com.finbourne.lusid.model.ResourceId;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Specification object for the parameters of an aggregation
 */
@ApiModel(description = "Specification object for the parameters of an aggregation")

public class AggregationRequest {
  public static final String SERIALIZED_NAME_RECIPE_ID = "recipeId";
  @SerializedName(SERIALIZED_NAME_RECIPE_ID)
  private ResourceId recipeId = null;

  public static final String SERIALIZED_NAME_INLINE_RECIPE = "inlineRecipe";
  @SerializedName(SERIALIZED_NAME_INLINE_RECIPE)
  private ConfigurationRecipe inlineRecipe = null;

  public static final String SERIALIZED_NAME_AS_AT = "asAt";
  @SerializedName(SERIALIZED_NAME_AS_AT)
  private OffsetDateTime asAt;

  public static final String SERIALIZED_NAME_EFFECTIVE_FROM = "effectiveFrom";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_FROM)
  private String effectiveFrom;

  public static final String SERIALIZED_NAME_EFFECTIVE_AT = "effectiveAt";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_AT)
  private String effectiveAt;

  public static final String SERIALIZED_NAME_METRICS = "metrics";
  @SerializedName(SERIALIZED_NAME_METRICS)
  private List<AggregateSpec> metrics = new ArrayList<>();

  public static final String SERIALIZED_NAME_GROUP_BY = "groupBy";
  @SerializedName(SERIALIZED_NAME_GROUP_BY)
  private List<String> groupBy = new ArrayList<>();

  public static final String SERIALIZED_NAME_FILTERS = "filters";
  @SerializedName(SERIALIZED_NAME_FILTERS)
  private List<PropertyFilter> filters = new ArrayList<>();

  public static final String SERIALIZED_NAME_LIMIT = "limit";
  @SerializedName(SERIALIZED_NAME_LIMIT)
  private Integer limit;

  public static final String SERIALIZED_NAME_SORT = "sort";
  @SerializedName(SERIALIZED_NAME_SORT)
  private List<OrderBySpec> sort = new ArrayList<>();

  public static final String SERIALIZED_NAME_REPORT_CCY = "reportCcy";
  @SerializedName(SERIALIZED_NAME_REPORT_CCY)
  private String reportCcy;

  public AggregationRequest recipeId(ResourceId recipeId) {
    this.recipeId = recipeId;
    return this;
  }

   /**
   * Get recipeId
   * @return recipeId
  **/
  @ApiModelProperty(value = "")
  public ResourceId getRecipeId() {
    return recipeId;
  }

  public void setRecipeId(ResourceId recipeId) {
    this.recipeId = recipeId;
  }

  public AggregationRequest inlineRecipe(ConfigurationRecipe inlineRecipe) {
    this.inlineRecipe = inlineRecipe;
    return this;
  }

   /**
   * Get inlineRecipe
   * @return inlineRecipe
  **/
  @ApiModelProperty(value = "")
  public ConfigurationRecipe getInlineRecipe() {
    return inlineRecipe;
  }

  public void setInlineRecipe(ConfigurationRecipe inlineRecipe) {
    this.inlineRecipe = inlineRecipe;
  }

  public AggregationRequest asAt(OffsetDateTime asAt) {
    this.asAt = asAt;
    return this;
  }

   /**
   * The asAt date to use
   * @return asAt
  **/
  @ApiModelProperty(value = "The asAt date to use")
  public OffsetDateTime getAsAt() {
    return asAt;
  }

  public void setAsAt(OffsetDateTime asAt) {
    this.asAt = asAt;
  }

  public AggregationRequest effectiveFrom(String effectiveFrom) {
    this.effectiveFrom = effectiveFrom;
    return this;
  }

   /**
   * If present, the EffectiveFrom and EffectiveAt dates are interpreted as a range of dates for which to perform a valuation.  In this case, valuation is calculated for the portfolio(s) for each date that is a business day in the given range.
   * @return effectiveFrom
  **/
  @ApiModelProperty(value = "If present, the EffectiveFrom and EffectiveAt dates are interpreted as a range of dates for which to perform a valuation.  In this case, valuation is calculated for the portfolio(s) for each date that is a business day in the given range.")
  public String getEffectiveFrom() {
    return effectiveFrom;
  }

  public void setEffectiveFrom(String effectiveFrom) {
    this.effectiveFrom = effectiveFrom;
  }

  public AggregationRequest effectiveAt(String effectiveAt) {
    this.effectiveAt = effectiveAt;
    return this;
  }

   /**
   * The market data time, i.e. the time to run the aggregation request effective of.
   * @return effectiveAt
  **/
  @ApiModelProperty(required = true, value = "The market data time, i.e. the time to run the aggregation request effective of.")
  public String getEffectiveAt() {
    return effectiveAt;
  }

  public void setEffectiveAt(String effectiveAt) {
    this.effectiveAt = effectiveAt;
  }

  public AggregationRequest metrics(List<AggregateSpec> metrics) {
    this.metrics = metrics;
    return this;
  }

  public AggregationRequest addMetricsItem(AggregateSpec metricsItem) {
    this.metrics.add(metricsItem);
    return this;
  }

   /**
   * The set of specifications for items to calculate or retrieve during the aggregation and present in the results.  This is logically equivalent to the set of operations in a Sql select statement  select [operation1(field1), operation2(field2), ... ] from results
   * @return metrics
  **/
  @ApiModelProperty(required = true, value = "The set of specifications for items to calculate or retrieve during the aggregation and present in the results.  This is logically equivalent to the set of operations in a Sql select statement  select [operation1(field1), operation2(field2), ... ] from results")
  public List<AggregateSpec> getMetrics() {
    return metrics;
  }

  public void setMetrics(List<AggregateSpec> metrics) {
    this.metrics = metrics;
  }

  public AggregationRequest groupBy(List<String> groupBy) {
    this.groupBy = groupBy;
    return this;
  }

  public AggregationRequest addGroupByItem(String groupByItem) {
    if (this.groupBy == null) {
      this.groupBy = new ArrayList<>();
    }
    this.groupBy.add(groupByItem);
    return this;
  }

   /**
   * The set of items by which to perform grouping. This primarily matters when one or more of the metric operators is a mapping  that reduces set size, e.g. sum or proportion. The group-by statement determines the set of keys by which to break the results out.
   * @return groupBy
  **/
  @ApiModelProperty(value = "The set of items by which to perform grouping. This primarily matters when one or more of the metric operators is a mapping  that reduces set size, e.g. sum or proportion. The group-by statement determines the set of keys by which to break the results out.")
  public List<String> getGroupBy() {
    return groupBy;
  }

  public void setGroupBy(List<String> groupBy) {
    this.groupBy = groupBy;
  }

  public AggregationRequest filters(List<PropertyFilter> filters) {
    this.filters = filters;
    return this;
  }

  public AggregationRequest addFiltersItem(PropertyFilter filtersItem) {
    if (this.filters == null) {
      this.filters = new ArrayList<>();
    }
    this.filters.add(filtersItem);
    return this;
  }

   /**
   * A set of filters to use to reduce the data found in a request. Equivalent to the &#39;where ...&#39; part of a Sql select statement.  For example, filter a set of values within a given range or matching a particular value.
   * @return filters
  **/
  @ApiModelProperty(value = "A set of filters to use to reduce the data found in a request. Equivalent to the 'where ...' part of a Sql select statement.  For example, filter a set of values within a given range or matching a particular value.")
  public List<PropertyFilter> getFilters() {
    return filters;
  }

  public void setFilters(List<PropertyFilter> filters) {
    this.filters = filters;
  }

  public AggregationRequest limit(Integer limit) {
    this.limit = limit;
    return this;
  }

   /**
   * limit the results to a particular number of values.
   * @return limit
  **/
  @ApiModelProperty(value = "limit the results to a particular number of values.")
  public Integer getLimit() {
    return limit;
  }

  public void setLimit(Integer limit) {
    this.limit = limit;
  }

  public AggregationRequest sort(List<OrderBySpec> sort) {
    this.sort = sort;
    return this;
  }

  public AggregationRequest addSortItem(OrderBySpec sortItem) {
    if (this.sort == null) {
      this.sort = new ArrayList<>();
    }
    this.sort.add(sortItem);
    return this;
  }

   /**
   * A (possibly empty/null) set of specifications for how to order the results.
   * @return sort
  **/
  @ApiModelProperty(value = "A (possibly empty/null) set of specifications for how to order the results.")
  public List<OrderBySpec> getSort() {
    return sort;
  }

  public void setSort(List<OrderBySpec> sort) {
    this.sort = sort;
  }

  public AggregationRequest reportCcy(String reportCcy) {
    this.reportCcy = reportCcy;
    return this;
  }

   /**
   * Three letter ISO currency string indicating what currency to report in for ReportCcy denominated queries.  If not present then the currency of the relevant portfolio will be used in its place where relevant.
   * @return reportCcy
  **/
  @ApiModelProperty(value = "Three letter ISO currency string indicating what currency to report in for ReportCcy denominated queries.  If not present then the currency of the relevant portfolio will be used in its place where relevant.")
  public String getReportCcy() {
    return reportCcy;
  }

  public void setReportCcy(String reportCcy) {
    this.reportCcy = reportCcy;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AggregationRequest aggregationRequest = (AggregationRequest) o;
    return Objects.equals(this.recipeId, aggregationRequest.recipeId) &&
        Objects.equals(this.inlineRecipe, aggregationRequest.inlineRecipe) &&
        Objects.equals(this.asAt, aggregationRequest.asAt) &&
        Objects.equals(this.effectiveFrom, aggregationRequest.effectiveFrom) &&
        Objects.equals(this.effectiveAt, aggregationRequest.effectiveAt) &&
        Objects.equals(this.metrics, aggregationRequest.metrics) &&
        Objects.equals(this.groupBy, aggregationRequest.groupBy) &&
        Objects.equals(this.filters, aggregationRequest.filters) &&
        Objects.equals(this.limit, aggregationRequest.limit) &&
        Objects.equals(this.sort, aggregationRequest.sort) &&
        Objects.equals(this.reportCcy, aggregationRequest.reportCcy);
  }

  @Override
  public int hashCode() {
    return Objects.hash(recipeId, inlineRecipe, asAt, effectiveFrom, effectiveAt, metrics, groupBy, filters, limit, sort, reportCcy);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AggregationRequest {\n");
    sb.append("    recipeId: ").append(toIndentedString(recipeId)).append("\n");
    sb.append("    inlineRecipe: ").append(toIndentedString(inlineRecipe)).append("\n");
    sb.append("    asAt: ").append(toIndentedString(asAt)).append("\n");
    sb.append("    effectiveFrom: ").append(toIndentedString(effectiveFrom)).append("\n");
    sb.append("    effectiveAt: ").append(toIndentedString(effectiveAt)).append("\n");
    sb.append("    metrics: ").append(toIndentedString(metrics)).append("\n");
    sb.append("    groupBy: ").append(toIndentedString(groupBy)).append("\n");
    sb.append("    filters: ").append(toIndentedString(filters)).append("\n");
    sb.append("    limit: ").append(toIndentedString(limit)).append("\n");
    sb.append("    sort: ").append(toIndentedString(sort)).append("\n");
    sb.append("    reportCcy: ").append(toIndentedString(reportCcy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
