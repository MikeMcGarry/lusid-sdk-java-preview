/*
 * LUSID API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.10.1389
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.finbourne.lusid.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * The set of options that control miscellaneous and default market resolution behaviour.  These are aimed at a &#39;crude&#39; level of control for those who do not wish to fine tune the way that data is resolved.  For clients who wish to simply match instruments to prices this is quite possibly sufficient. For those wishing to control market data sources  according to requirements based on accuracy or timeliness it is not. In more advanced cases the options should largely be ignored and rules specified  per source. Be aware that where no specified rule matches the final fallback is on to the logic implied here.
 */
@ApiModel(description = "The set of options that control miscellaneous and default market resolution behaviour.  These are aimed at a 'crude' level of control for those who do not wish to fine tune the way that data is resolved.  For clients who wish to simply match instruments to prices this is quite possibly sufficient. For those wishing to control market data sources  according to requirements based on accuracy or timeliness it is not. In more advanced cases the options should largely be ignored and rules specified  per source. Be aware that where no specified rule matches the final fallback is on to the logic implied here.")

public class MarketOptions {
  /**
   * The default supplier of data. This controls which &#39;dialect&#39; is used to find particular market data. e.g. one supplier might address data by RIC, another by PermId
   */
  @JsonAdapter(DefaultSupplierEnum.Adapter.class)
  public enum DefaultSupplierEnum {
    DATASCOPE("DataScope"),
    
    LUSID("Lusid"),
    
    ISDA("Isda"),
    
    CLIENT("Client"),
    
    EDI("Edi"),
    
    TRADERMADE("TraderMade"),
    
    FACTSET("FactSet");

    private String value;

    DefaultSupplierEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DefaultSupplierEnum fromValue(String value) {
      for (DefaultSupplierEnum b : DefaultSupplierEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DefaultSupplierEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DefaultSupplierEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DefaultSupplierEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return DefaultSupplierEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_DEFAULT_SUPPLIER = "defaultSupplier";
  @SerializedName(SERIALIZED_NAME_DEFAULT_SUPPLIER)
  private DefaultSupplierEnum defaultSupplier;

  /**
   * When instrument quotes are searched for, what identifier should be used by default
   */
  @JsonAdapter(DefaultInstrumentCodeTypeEnum.Adapter.class)
  public enum DefaultInstrumentCodeTypeEnum {
    LUSIDINSTRUMENTID("LusidInstrumentId"),
    
    FIGI("Figi"),
    
    RIC("RIC"),
    
    QUOTEPERMID("QuotePermId"),
    
    ISIN("Isin"),
    
    CURRENCYPAIR("CurrencyPair");

    private String value;

    DefaultInstrumentCodeTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DefaultInstrumentCodeTypeEnum fromValue(String value) {
      for (DefaultInstrumentCodeTypeEnum b : DefaultInstrumentCodeTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DefaultInstrumentCodeTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DefaultInstrumentCodeTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DefaultInstrumentCodeTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return DefaultInstrumentCodeTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_DEFAULT_INSTRUMENT_CODE_TYPE = "defaultInstrumentCodeType";
  @SerializedName(SERIALIZED_NAME_DEFAULT_INSTRUMENT_CODE_TYPE)
  private DefaultInstrumentCodeTypeEnum defaultInstrumentCodeType;

  public static final String SERIALIZED_NAME_DEFAULT_SCOPE = "defaultScope";
  @SerializedName(SERIALIZED_NAME_DEFAULT_SCOPE)
  private String defaultScope;

  public static final String SERIALIZED_NAME_ATTEMPT_TO_INFER_MISSING_FX = "attemptToInferMissingFx";
  @SerializedName(SERIALIZED_NAME_ATTEMPT_TO_INFER_MISSING_FX)
  private Boolean attemptToInferMissingFx;

  /**
   * Gets or Sets manifestLevelOfDetail
   */
  @JsonAdapter(ManifestLevelOfDetailEnum.Adapter.class)
  public enum ManifestLevelOfDetailEnum {
    NONE("None"),
    
    FULL("Full");

    private String value;

    ManifestLevelOfDetailEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ManifestLevelOfDetailEnum fromValue(String value) {
      for (ManifestLevelOfDetailEnum b : ManifestLevelOfDetailEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ManifestLevelOfDetailEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ManifestLevelOfDetailEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ManifestLevelOfDetailEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ManifestLevelOfDetailEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_MANIFEST_LEVEL_OF_DETAIL = "manifestLevelOfDetail";
  @SerializedName(SERIALIZED_NAME_MANIFEST_LEVEL_OF_DETAIL)
  private ManifestLevelOfDetailEnum manifestLevelOfDetail;

  public MarketOptions defaultSupplier(DefaultSupplierEnum defaultSupplier) {
    this.defaultSupplier = defaultSupplier;
    return this;
  }

   /**
   * The default supplier of data. This controls which &#39;dialect&#39; is used to find particular market data. e.g. one supplier might address data by RIC, another by PermId
   * @return defaultSupplier
  **/
  @ApiModelProperty(value = "The default supplier of data. This controls which 'dialect' is used to find particular market data. e.g. one supplier might address data by RIC, another by PermId")
  public DefaultSupplierEnum getDefaultSupplier() {
    return defaultSupplier;
  }

  public void setDefaultSupplier(DefaultSupplierEnum defaultSupplier) {
    this.defaultSupplier = defaultSupplier;
  }

  public MarketOptions defaultInstrumentCodeType(DefaultInstrumentCodeTypeEnum defaultInstrumentCodeType) {
    this.defaultInstrumentCodeType = defaultInstrumentCodeType;
    return this;
  }

   /**
   * When instrument quotes are searched for, what identifier should be used by default
   * @return defaultInstrumentCodeType
  **/
  @ApiModelProperty(value = "When instrument quotes are searched for, what identifier should be used by default")
  public DefaultInstrumentCodeTypeEnum getDefaultInstrumentCodeType() {
    return defaultInstrumentCodeType;
  }

  public void setDefaultInstrumentCodeType(DefaultInstrumentCodeTypeEnum defaultInstrumentCodeType) {
    this.defaultInstrumentCodeType = defaultInstrumentCodeType;
  }

  public MarketOptions defaultScope(String defaultScope) {
    this.defaultScope = defaultScope;
    return this;
  }

   /**
   * For default rules, which scope should data be searched for in
   * @return defaultScope
  **/
  @ApiModelProperty(value = "For default rules, which scope should data be searched for in")
  public String getDefaultScope() {
    return defaultScope;
  }

  public void setDefaultScope(String defaultScope) {
    this.defaultScope = defaultScope;
  }

  public MarketOptions attemptToInferMissingFx(Boolean attemptToInferMissingFx) {
    this.attemptToInferMissingFx = attemptToInferMissingFx;
    return this;
  }

   /**
   * if true will calculate a missing Fx pair (e.g. THBJPY) from the inverse JPYTHB or from standardised pairs against USD, e.g. THBUSD and JPYUSD
   * @return attemptToInferMissingFx
  **/
  @ApiModelProperty(value = "if true will calculate a missing Fx pair (e.g. THBJPY) from the inverse JPYTHB or from standardised pairs against USD, e.g. THBUSD and JPYUSD")
  public Boolean getAttemptToInferMissingFx() {
    return attemptToInferMissingFx;
  }

  public void setAttemptToInferMissingFx(Boolean attemptToInferMissingFx) {
    this.attemptToInferMissingFx = attemptToInferMissingFx;
  }

  public MarketOptions manifestLevelOfDetail(ManifestLevelOfDetailEnum manifestLevelOfDetail) {
    this.manifestLevelOfDetail = manifestLevelOfDetail;
    return this;
  }

   /**
   * Get manifestLevelOfDetail
   * @return manifestLevelOfDetail
  **/
  @ApiModelProperty(value = "")
  public ManifestLevelOfDetailEnum getManifestLevelOfDetail() {
    return manifestLevelOfDetail;
  }

  public void setManifestLevelOfDetail(ManifestLevelOfDetailEnum manifestLevelOfDetail) {
    this.manifestLevelOfDetail = manifestLevelOfDetail;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MarketOptions marketOptions = (MarketOptions) o;
    return Objects.equals(this.defaultSupplier, marketOptions.defaultSupplier) &&
        Objects.equals(this.defaultInstrumentCodeType, marketOptions.defaultInstrumentCodeType) &&
        Objects.equals(this.defaultScope, marketOptions.defaultScope) &&
        Objects.equals(this.attemptToInferMissingFx, marketOptions.attemptToInferMissingFx) &&
        Objects.equals(this.manifestLevelOfDetail, marketOptions.manifestLevelOfDetail);
  }

  @Override
  public int hashCode() {
    return Objects.hash(defaultSupplier, defaultInstrumentCodeType, defaultScope, attemptToInferMissingFx, manifestLevelOfDetail);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MarketOptions {\n");
    sb.append("    defaultSupplier: ").append(toIndentedString(defaultSupplier)).append("\n");
    sb.append("    defaultInstrumentCodeType: ").append(toIndentedString(defaultInstrumentCodeType)).append("\n");
    sb.append("    defaultScope: ").append(toIndentedString(defaultScope)).append("\n");
    sb.append("    attemptToInferMissingFx: ").append(toIndentedString(attemptToInferMissingFx)).append("\n");
    sb.append("    manifestLevelOfDetail: ").append(toIndentedString(manifestLevelOfDetail)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
